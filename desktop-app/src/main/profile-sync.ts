import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';
import AdmZip from 'adm-zip';

// Directories/files to exclude from profile zip (caches, temp files)
// These are regenerated by Chrome and add significant size
const EXCLUDE_DIRS = new Set([
  // Caches (regenerated by Chrome)
  'Cache',
  'Code Cache',
  'GPUCache',
  'GrShaderCache',
  'ShaderCache',
  'DawnCache',
  'DawnWebGPUCache',
  'DawnGraphiteCache',
  'GraphiteDawnCache',
  'CacheStorage',
  // Service workers (regenerated, often 30-40 MB)
  'Service Worker',
  // Chrome internal data (regenerated)
  'File System',
  'blob_storage',
  'BrowserMetrics',
  'Crashpad',
  'Safe Browsing',
  'Safe Browsing Network',
  'optimization_guide_model_store',
  'optimization_guide_prediction_model_downloads',
  'session-storage-backup',
  'PersistentOriginTrials',
  // Chrome components & preloaded data (re-downloaded automatically)
  'component_crx_cache',
  'extensions_crx_cache',
  'WidevineCdm',
  'MEIPreload',
  'SSLErrorAssistant',
  'CertificateRevocation',
  'PKIMetadata',
  'OriginTrials',
  'FileTypePolicies',
  'Subresource Filter',
  'SafetyTips',
  'TrustTokenKeyCommitments',
  'Crowd Deny',
  'Fingerprinting Protection Filter',
  'FirstPartySetsPreloaded',
  'MaskedDomainListPreloaded',
  'PrivacySandboxAttestationsPreloaded',
  'PlusAddressBlocklist',
  'ProbabilisticRevealTokenRegistry',
  'TpcdMetadata',
  'OnDeviceHeadSuggestModel',
  'WasmTtsEngine',
  'ZxcvbnData',
  'hyphen-data',
  'AmountExtractionHeuristicRegexes',
  'AutofillStates',
  'HistorySearch',
  'OpenCookieDatabase',
  'CookieReadinessList',
  'segmentation_platform',
  'Segmentation Platform',
  // Default/ subdirs that are regenerated
  'AutofillStrikeDatabase',
  'BudgetDatabase',
  'Feature Engagement Tracker',
  'Shared Dictionary',
  'DataSharing',
  'Collaboration',
  'GCM Store',
  'power_bookmarks',
  'chrome_cart_db',
  'commerce_subscription_db',
  'discount_infos_db',
  'discounts_db',
  'parcel_tracking_db',
]);

const EXCLUDE_PATTERNS = [
  /\.tmp$/i,
  /\.log$/i,
  /^LOG$/,
  /^LOG\.old$/,
  /^LOCK$/,
  /-journal$/,
  /\.bak$/,
  /^SingletonCookie$/,
  /^SingletonLock$/,
  /^SingletonSocket$/,
  /^BrowserMetrics-spare\.pma$/,
  /^crash_count$/,
  /^DevToolsActivePort$/,
  /^Variations$/,
  /^Last Browser$/,
  /^Last Version$/,
  /^first_party_sets\.db/,
  /^heavy_ad_intervention_opt_out\.db/,
  /^DIPS$/,
  /^Account Web Data$/,
  /^Affiliation Database/,
  /^Network Action Predictor/,
  /^ServerCertificate/,
  /^Top Sites/,
  /^Shortcuts/,
  /^MediaDeviceSalts/,
];

// Max compressed size: 100MB
const MAX_SYNC_SIZE = 100 * 1024 * 1024;

function getProfilesBaseDir(): string {
  return process.platform === 'win32'
    ? path.join(os.homedir(), 'AppData', 'Local', 'AntidetectBrowser', 'Profiles')
    : path.join(os.homedir(), '.antidetect-browser', 'profiles');
}

function getProfilePath(profileId: string): string {
  return path.join(getProfilesBaseDir(), profileId);
}

function shouldExclude(relativePath: string): boolean {
  const parts = relativePath.split(path.sep);

  // Check if any directory component is in the exclusion set
  for (const part of parts) {
    if (EXCLUDE_DIRS.has(part)) return true;
  }

  // Check filename patterns
  const filename = parts[parts.length - 1];
  for (const pattern of EXCLUDE_PATTERNS) {
    if (pattern.test(filename)) return true;
  }

  return false;
}

function addDirToZip(zip: AdmZip, dirPath: string, zipPrefix: string): void {
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);
    const zipPath = zipPrefix ? `${zipPrefix}/${entry.name}` : entry.name;

    if (shouldExclude(zipPath)) continue;

    if (entry.isDirectory()) {
      addDirToZip(zip, fullPath, zipPath);
    } else if (entry.isFile()) {
      try {
        const content = fs.readFileSync(fullPath);
        zip.addFile(zipPath, content);
      } catch {
        // Skip files that can't be read (locked by Chrome, etc.)
      }
    }
  }
}

/**
 * Compress a Chrome profile directory into a zip buffer.
 * Excludes cache directories and temp files to minimize size.
 */
export async function zipProfileDir(profileId: string): Promise<{ buffer: Buffer; size: number }> {
  const profilePath = getProfilePath(profileId);

  if (!fs.existsSync(profilePath)) {
    throw new Error(`Profile directory not found: ${profilePath}`);
  }

  console.log(`[ProfileSync] Zipping profile: ${profileId}`);
  const zip = new AdmZip();
  addDirToZip(zip, profilePath, '');

  const buffer = zip.toBuffer();
  console.log(`[ProfileSync] Zip size: ${(buffer.length / 1024 / 1024).toFixed(2)} MB`);

  if (buffer.length > MAX_SYNC_SIZE) {
    console.warn(`[ProfileSync] Profile zip exceeds ${MAX_SYNC_SIZE / 1024 / 1024}MB limit`);
  }

  return { buffer, size: buffer.length };
}

/**
 * Extract a zip buffer into a Chrome profile directory.
 * Creates a backup of existing data before extraction.
 */
export async function unzipProfileDir(profileId: string, zipBuffer: Buffer): Promise<void> {
  const profilePath = getProfilePath(profileId);
  const backupPath = profilePath + '.backup';

  console.log(`[ProfileSync] Unzipping profile: ${profileId}`);

  // Backup existing directory
  if (fs.existsSync(profilePath)) {
    if (fs.existsSync(backupPath)) {
      fs.rmSync(backupPath, { recursive: true, force: true });
    }
    fs.renameSync(profilePath, backupPath);
  }

  try {
    fs.mkdirSync(profilePath, { recursive: true });
    const zip = new AdmZip(zipBuffer);
    zip.extractAllTo(profilePath, true);
    console.log(`[ProfileSync] Profile extracted successfully`);

    // Remove backup on success
    if (fs.existsSync(backupPath)) {
      fs.rmSync(backupPath, { recursive: true, force: true });
    }
  } catch (error) {
    console.error(`[ProfileSync] Extraction failed, restoring backup:`, error);
    // Restore backup on failure
    if (fs.existsSync(backupPath)) {
      if (fs.existsSync(profilePath)) {
        fs.rmSync(profilePath, { recursive: true, force: true });
      }
      fs.renameSync(backupPath, profilePath);
    }
    throw error;
  }
}

/**
 * Check if a local Chrome profile directory exists with actual data.
 */
export function profileDirExists(profileId: string): boolean {
  const profilePath = getProfilePath(profileId);
  if (!fs.existsSync(profilePath)) return false;

  // Check for Default/Preferences as indicator of a real profile
  const prefsPath = path.join(profilePath, 'Default', 'Preferences');
  return fs.existsSync(prefsPath);
}

/**
 * Get the local sync version for a profile.
 * Returns 0 if no sync version file exists.
 */
export function getLocalSyncVersion(profileId: string): number {
  const versionPath = path.join(getProfilePath(profileId), '.sync_version');
  try {
    if (fs.existsSync(versionPath)) {
      return parseInt(fs.readFileSync(versionPath, 'utf8').trim(), 10) || 0;
    }
  } catch {}
  return 0;
}

/**
 * Set the local sync version for a profile.
 */
export function setLocalSyncVersion(profileId: string, version: number): void {
  const profilePath = getProfilePath(profileId);
  if (!fs.existsSync(profilePath)) {
    fs.mkdirSync(profilePath, { recursive: true });
  }
  fs.writeFileSync(path.join(profilePath, '.sync_version'), String(version));
}
