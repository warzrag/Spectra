import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';
import AdmZip from 'adm-zip';

// Directories/files to exclude from profile zip (caches, temp files)
// These are regenerated by Chrome and add significant size
const EXCLUDE_DIRS = new Set([
  'Cache',
  'Code Cache',
  'GPUCache',
  'GrShaderCache',
  'ShaderCache',
  'DawnCache',
  'DawnWebGPUCache',
  'Service Worker',
  'CacheStorage',
  'File System',
  'blob_storage',
  'BrowserMetrics',
  'Crashpad',
  'Safe Browsing',
  'optimization_guide_model_store',
  'optimization_guide_prediction_model_downloads',
  'session-storage-backup',
  'PersistentOriginTrials',
]);

const EXCLUDE_PATTERNS = [
  /\.tmp$/i,
  /\.log$/i,
  /^LOG$/,
  /^LOG\.old$/,
  /^LOCK$/,
  /-journal$/,
  /\.bak$/,
  /^SingletonCookie$/,
  /^SingletonLock$/,
  /^SingletonSocket$/,
  /^BrowserMetrics-spare\.pma$/,
  /^crash_count$/,
];

// Max compressed size: 100MB
const MAX_SYNC_SIZE = 100 * 1024 * 1024;

function getProfilesBaseDir(): string {
  return process.platform === 'win32'
    ? path.join(os.homedir(), 'AppData', 'Local', 'AntidetectBrowser', 'Profiles')
    : path.join(os.homedir(), '.antidetect-browser', 'profiles');
}

function getProfilePath(profileId: string): string {
  return path.join(getProfilesBaseDir(), profileId);
}

function shouldExclude(relativePath: string): boolean {
  const parts = relativePath.split(path.sep);

  // Check if any directory component is in the exclusion set
  for (const part of parts) {
    if (EXCLUDE_DIRS.has(part)) return true;
  }

  // Check filename patterns
  const filename = parts[parts.length - 1];
  for (const pattern of EXCLUDE_PATTERNS) {
    if (pattern.test(filename)) return true;
  }

  return false;
}

function addDirToZip(zip: AdmZip, dirPath: string, zipPrefix: string): void {
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);
    const zipPath = zipPrefix ? `${zipPrefix}/${entry.name}` : entry.name;

    if (shouldExclude(zipPath)) continue;

    if (entry.isDirectory()) {
      addDirToZip(zip, fullPath, zipPath);
    } else if (entry.isFile()) {
      try {
        const content = fs.readFileSync(fullPath);
        zip.addFile(zipPath, content);
      } catch {
        // Skip files that can't be read (locked by Chrome, etc.)
      }
    }
  }
}

/**
 * Compress a Chrome profile directory into a zip buffer.
 * Excludes cache directories and temp files to minimize size.
 */
export async function zipProfileDir(profileId: string): Promise<{ buffer: Buffer; size: number }> {
  const profilePath = getProfilePath(profileId);

  if (!fs.existsSync(profilePath)) {
    throw new Error(`Profile directory not found: ${profilePath}`);
  }

  console.log(`[ProfileSync] Zipping profile: ${profileId}`);
  const zip = new AdmZip();
  addDirToZip(zip, profilePath, '');

  const buffer = zip.toBuffer();
  console.log(`[ProfileSync] Zip size: ${(buffer.length / 1024 / 1024).toFixed(2)} MB`);

  if (buffer.length > MAX_SYNC_SIZE) {
    console.warn(`[ProfileSync] Profile zip exceeds ${MAX_SYNC_SIZE / 1024 / 1024}MB limit`);
  }

  return { buffer, size: buffer.length };
}

/**
 * Extract a zip buffer into a Chrome profile directory.
 * Creates a backup of existing data before extraction.
 */
export async function unzipProfileDir(profileId: string, zipBuffer: Buffer): Promise<void> {
  const profilePath = getProfilePath(profileId);
  const backupPath = profilePath + '.backup';

  console.log(`[ProfileSync] Unzipping profile: ${profileId}`);

  // Backup existing directory
  if (fs.existsSync(profilePath)) {
    if (fs.existsSync(backupPath)) {
      fs.rmSync(backupPath, { recursive: true, force: true });
    }
    fs.renameSync(profilePath, backupPath);
  }

  try {
    fs.mkdirSync(profilePath, { recursive: true });
    const zip = new AdmZip(zipBuffer);
    zip.extractAllTo(profilePath, true);
    console.log(`[ProfileSync] Profile extracted successfully`);

    // Remove backup on success
    if (fs.existsSync(backupPath)) {
      fs.rmSync(backupPath, { recursive: true, force: true });
    }
  } catch (error) {
    console.error(`[ProfileSync] Extraction failed, restoring backup:`, error);
    // Restore backup on failure
    if (fs.existsSync(backupPath)) {
      if (fs.existsSync(profilePath)) {
        fs.rmSync(profilePath, { recursive: true, force: true });
      }
      fs.renameSync(backupPath, profilePath);
    }
    throw error;
  }
}

/**
 * Check if a local Chrome profile directory exists with actual data.
 */
export function profileDirExists(profileId: string): boolean {
  const profilePath = getProfilePath(profileId);
  if (!fs.existsSync(profilePath)) return false;

  // Check for Default/Preferences as indicator of a real profile
  const prefsPath = path.join(profilePath, 'Default', 'Preferences');
  return fs.existsSync(prefsPath);
}

/**
 * Get the local sync version for a profile.
 * Returns 0 if no sync version file exists.
 */
export function getLocalSyncVersion(profileId: string): number {
  const versionPath = path.join(getProfilePath(profileId), '.sync_version');
  try {
    if (fs.existsSync(versionPath)) {
      return parseInt(fs.readFileSync(versionPath, 'utf8').trim(), 10) || 0;
    }
  } catch {}
  return 0;
}

/**
 * Set the local sync version for a profile.
 */
export function setLocalSyncVersion(profileId: string, version: number): void {
  const profilePath = getProfilePath(profileId);
  if (!fs.existsSync(profilePath)) {
    fs.mkdirSync(profilePath, { recursive: true });
  }
  fs.writeFileSync(path.join(profilePath, '.sync_version'), String(version));
}
